1. When screen width is X, scroll down, forcing out-of-view elements back to default styles. Then scroll back up at the same screen width. The now-visible elements should be at the correct fluid size now. Setting `element.updateWidth = undefined` is what assures this.
2. If we only measured `lastUpdateWidth` on each global update to decide on recomputation(or not), we would have elements that get stuck on stale default values. Imagine screen width `100px`, then scroll elements out of view. They now went to defaults. Now you scroll back to them, at same screen width, so `lastUpdateWidth` is `100px`. Based on this, we need not update! So they would be stuck at defaults. Therefore, we track `updateWidth` per element. It gets set whenever the element got a full fluid update, which only happens if it's visible.
3. % can depend on a target style, whether that's the width, the font size, etc. We want to recompute values if the style of target changed.
4. % can depend on a target element size. If that's the case, the target is set and we observe it for change. If size changed again, we force re-calculation.
5. Most people write set of media queries dedicated to particular content, right after the content. The next set of non-media rules is new content. For speed, the engine only scans the next future media query stack for max value, and cancels if not found there (on next non-media rule after medias). Make sure it cancels properly!
6. Spans should fall back to default values for the span range - that's why we return after applying start span. Ensure this works correctly (default values too), and test spans that start not just at baseline width, but maybe 1st/2nd media query.
7. Make sure newly activated dynamic fluid properties override the currently applied styles, even for same screen width. Order ID check in `repeatComputedValue` is there for this.
8. Infinite screen flicker bug. V0.1 had this. It seems when an element becomes hidden/visible, the style change can revert the visibility status. Then again, the next style inverts it again. This goes on forever, causing flickering. We can fix this by storing the scroll X/Y position on last visibility/hidden shift. If the position is same, preserve the same style by returning before update.
9. Ensure only visible elements get calculated.
10. Keyword measurer/grid template shadow - make sure they don't override the real style. If you don't set back the real style after measurement, the `appliedValue` is no longer the same as current style. The style set gets skipped as `value === appliedValue`, and the style is wrong. So for this reason, we set the style back after measuring.
11. Keyword measurer falls back to string if the number can't be parsed with floatParse. This causes snapping for those incompatible values, as all string values snap.
12. Failed at creating good interpolation for margin auto. Implemented fallback mechanism - margin auto returns `auto`, causing snap, as all string values snap.
